/**
 * @license React
 * eslint-plugin-react-hooks.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';function aa(a,c){if(a){if("string"===typeof a)return da(a,c);var b=Object.prototype.toString.call(a).slice(8,-1);"Object"===b&&a.constructor&&(b=a.constructor.name);if("Map"===b||"Set"===b)return Array.from(a);if("Arguments"===b||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(b))return da(a,c)}}function da(a,c){if(null==c||c>a.length)c=a.length;for(var b=0,d=Array(c);b<c;b++)d[b]=a[b];return d}
function z(a,c){var b;if("undefined"===typeof Symbol||null==a[Symbol.iterator]){if(Array.isArray(a)||(b=aa(a))||c&&a&&"number"===typeof a.length){b&&(a=b);var d=0;c=function(){};return{s:c,n:function(){return d>=a.length?{done:!0}:{done:!1,value:a[d++]}},e:function(a){throw a;},f:c}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var e=!0,x=!1,f;return{s:function(){b=a[Symbol.iterator]()},
n:function(){var a=b.next();e=a.done;return a},e:function(a){x=!0;f=a},f:function(){try{e||null==b.return||b.return()}finally{if(x)throw f;}}}}function E(a){if("Identifier"===a.type)return/^use[A-Z0-9].*$/.test(a.name);if("MemberExpression"===a.type&&!a.computed&&E(a.property)){a=a.object;var c=/^[A-Z].*/;return"Identifier"===a.type&&c.test(a.name)}return!1}function ea(a){return"Identifier"===a.type?!/^[a-z]/.test(a.name):!1}
function fa(a,c){return a.name===c||"MemberExpression"===a.type&&"React"===a.object.name&&a.property.name===c}function ha(a){return!!(a.parent&&a.parent.callee&&fa(a.parent.callee,"forwardRef"))}function ia(a){return!!(a.parent&&a.parent.callee&&fa(a.parent.callee,"memo"))}function ja(a){for(;a;){var c=na(a);if(c&&(ea(c)||E(c))||ha(a)||ia(a))return!0;a=a.parent}return!1}
function na(a){if("FunctionDeclaration"===a.type||"FunctionExpression"===a.type&&a.id)return a.id;if("FunctionExpression"===a.type||"ArrowFunctionExpression"===a.type)return"VariableDeclarator"===a.parent.type&&a.parent.init===a?a.parent.id:"AssignmentExpression"===a.parent.type&&a.parent.right===a&&"="===a.parent.operator?a.parent.left:"Property"!==a.parent.type||a.parent.value!==a||a.parent.computed?"AssignmentPattern"!==a.parent.type||a.parent.right!==a||a.parent.computed?void 0:a.parent.left:
a.parent.key}
function G(a){function c(){return{isUsed:!1,isSatisfiedRecursively:!1,isSubtreeUsed:!1,children:new Map}}function b(a,b){b=b.split(".");b=z(b);var k;try{for(b.s();!(k=b.n()).done;){var d=k.value,e=a.children.get(d);e||(e=c(),a.children.set(d,e));a=e}}catch(r){b.e(r)}finally{b.f()}return a}function d(a,c,b){c=c.split(".");c=z(c);var d;try{for(c.s();!(d=c.n()).done;){var k=a.children.get(d.value);if(!k)break;b(k);a=k}}catch(r){c.e(r)}finally{c.f()}}function e(a,c,b,d){a.children.forEach(function(a,k){var f=
d(k);a.isSatisfiedRecursively?a.isSubtreeUsed&&b.add(f):a.isUsed?c.add(f):e(a,c,b,function(a){return f+"."+a})})}var x=a.dependencies,f=a.declaredDependencies,w=a.stableDependencies,l=a.externalDependencies,A=a.isEffect,n=c();x.forEach(function(a,c){b(n,c).isUsed=!0;d(n,c,function(a){a.isSubtreeUsed=!0})});f.forEach(function(a){b(n,a.key).isSatisfiedRecursively=!0});w.forEach(function(a){b(n,a).isSatisfiedRecursively=!0});a=new Set;var D=new Set;e(n,a,D,function(a){return a});var g=[],m=new Set,u=
new Set;f.forEach(function(a){a=a.key;D.has(a)?-1===g.indexOf(a)?g.push(a):u.add(a):!A||a.endsWith(".current")||l.has(a)?m.add(a):-1===g.indexOf(a)&&g.push(a)});a.forEach(function(a){g.push(a)});return{suggestedDependencies:g,unnecessaryDependencies:m,duplicateDependencies:u,missingDependencies:a}}
function T(a){switch(a.type){case "ObjectExpression":return"object";case "ArrayExpression":return"array";case "ArrowFunctionExpression":case "FunctionExpression":return"function";case "ClassExpression":return"class";case "ConditionalExpression":if(null!=T(a.consequent)||null!=T(a.alternate))return"conditional";break;case "LogicalExpression":if(null!=T(a.left)||null!=T(a.right))return"logical expression";break;case "JSXFragment":return"JSX fragment";case "JSXElement":return"JSX element";case "AssignmentExpression":if(null!=
T(a.right))return"assignment expression";break;case "NewExpression":return"object construction";case "Literal":if(a.value instanceof RegExp)return"regular expression";break;case "TypeCastExpression":return T(a.expression);case "TSAsExpression":return T(a.expression)}return null}
function oa(a){var c=a.declaredDependenciesNode,b=a.componentScope,d=a.scope;return a.declaredDependencies.map(function(a){var c=a.key;a=b.variables.find(function(a){return a.name===c});if(null==a)return null;var d=a.defs[0];if(null==d)return null;if("Variable"===d.type&&"VariableDeclarator"===d.node.type&&"Identifier"===d.node.id.type&&null!=d.node.init){var e=T(d.node.init);if(null!=e)return[a,e]}return"FunctionName"===d.type&&"FunctionDeclaration"===d.node.type?[a,"function"]:"ClassName"===d.type&&
"ClassDeclaration"===d.node.type?[a,"class"]:null}).filter(Boolean).map(function(a){var b=a[0];a=a[1];var e=b.defs[0];a:{for(var w=!1,l=0;l<b.references.length;l++){var A=b.references[l];if(A.writeExpr)if(w){b=!0;break a}else{w=!0;continue}for(var n=A.from;n!==d&&null!=n;)n=n.upper;if(n!==d&&!pa(c,A.identifier)){b=!0;break a}}b=!1}return{construction:e,depType:a,isUsedOutsideOfHook:b}})}
function qa(a,c){return"MemberExpression"!==a.parent.type&&"OptionalMemberExpression"!==a.parent.type||a.parent.object!==a||"current"===a.parent.property.name||a.parent.computed||!("always"===c||"props"===c&&"props"===a.name||null==a.parent.parent||"CallExpression"!==a.parent.parent.type&&"OptionalCallExpression"!==a.parent.parent.type)&&a.parent.parent.callee===a.parent?"MemberExpression"===a.type&&a.parent&&"AssignmentExpression"===a.parent.type&&a.parent.left===a?a.object:a:qa(a.parent,c)}
function Y(a,c,b){c&&(a.optional?c.has(b)||c.set(b,!0):c.set(b,!1))}
function Z(a,c){if("Identifier"===a.type||"JSXIdentifier"===a.type)return a=a.name,c&&c.set(a,!1),a;if("MemberExpression"!==a.type||a.computed){if("OptionalMemberExpression"!==a.type||a.computed){if("ChainExpression"!==a.type||a.computed)throw Error("Unsupported node type: "+a.type);a=a.expression;if("CallExpression"===a.type)throw Error("Unsupported node type: "+a.type);var b=Z(a.object,c),d=Z(a.property,null);b=b+"."+d;Y(a,c,b);return b}b=Z(a.object,c);d=Z(a.property,null);b=b+"."+d;Y(a,c,b);return b}b=
Z(a.object,c);d=Z(a.property,null);b=b+"."+d;Y(a,c,b);return b}function ta(a){return"MemberExpression"!==a.type||"Identifier"!==a.object.type||"React"!==a.object.name||"Identifier"!==a.property.type||a.computed?a:a.property}
function ua(a,c){var b=ta(a);if("Identifier"!==b.type)return-1;switch(b.name){case "useEffect":case "useLayoutEffect":case "useCallback":case "useMemo":return 0;case "useImperativeHandle":return 1;default:if(b===a&&c&&c.additionalHooks){try{var d=Z(b,null)}catch(e){if(/Unsupported node type/.test(e.message))return 0;throw e;}return c.additionalHooks.test(d)?0:-1}return-1}}
function va(a,c){for(var b=[a],d=null;b.length;){d=b.shift();if(("Identifier"===d.type||"JSXIdentifier"===d.type)&&d.type===c.type&&d.name===c.name&&d.range[0]===c.range[0]&&d.range[1]===c.range[1])return d;if(pa(d,c)){a=0;for(var e=Object.entries(d);a<e.length;a++){var x=e[a],f=x[1];"parent"!==x[0]&&(wa(f)?(f.parent=d,b.push(f)):Array.isArray(f)&&f.forEach(function(a){wa(a)&&(a.parent=d,b.push(a))}))}}}return null}
function xa(a){for(var c="",b=0;b<a.length;b++)c+=a[b],0===b&&2===a.length?c+=" and ":b===a.length-2&&2<a.length?c+=", and ":b<a.length-1&&(c+=", ");return c}function wa(a){return"object"===typeof a&&null!==a&&!Array.isArray(a)&&"string"===typeof a.type}function pa(a,c){return a.range[0]<=c.range[0]&&a.range[1]>=c.range[1]}exports.configs={recommended:{plugins:["react-hooks"],rules:{"react-hooks/rules-of-hooks":"error","react-hooks/exhaustive-deps":"warn"}}};
exports.rules={"rules-of-hooks":{meta:{type:"problem",docs:{description:"enforces the Rules of Hooks",recommended:!0,url:"https://reactjs.org/docs/hooks-rules.html"}},create:function(a){var c=[],b=[];return{onCodePathSegmentStart:function(a){return b.push(a)},onCodePathSegmentEnd:function(){return b.pop()},onCodePathStart:function(){return c.push(new Map)},onCodePathEnd:function(b,e){function d(a,c){var h=d.cache,e=h.get(a.id);c=new Set(c);if(c.has(a.id)){h=[].concat(c);a=h.slice(h.indexOf(a.id)+
1);a=z(a);var m;try{for(a.s();!(m=a.n()).done;)A.add(m.value)}catch(y){a.e(y)}finally{a.f()}return BigInt("0")}c.add(a.id);if(void 0!==e)return e;if(b.thrownSegments.includes(a))e=BigInt("0");else if(0===a.prevSegments.length)e=BigInt("1");else{e=BigInt("0");m=z(a.prevSegments);var g;try{for(m.s();!(g=m.n()).done;)e+=d(g.value,c)}catch(y){m.e(y)}finally{m.f()}}a.reachable&&e===BigInt("0")?h.delete(a.id):h.set(a.id,e);return e}function f(a,c){var d=f.cache,e=d.get(a.id);c=new Set(c);if(c.has(a.id)){d=
Array.from(c);a=d.slice(d.indexOf(a.id)+1);a=z(a);var m;try{for(a.s();!(m=a.n()).done;)A.add(m.value)}catch(y){a.e(y)}finally{a.f()}return BigInt("0")}c.add(a.id);if(void 0!==e)return e;if(b.thrownSegments.includes(a))e=BigInt("0");else if(0===a.nextSegments.length)e=BigInt("1");else{e=BigInt("0");m=z(a.nextSegments);var g;try{for(m.s();!(g=m.n()).done;)e+=f(g.value,c)}catch(y){m.e(y)}finally{m.f()}}d.set(a.id,e);return e}function w(a){var c=w.cache,b=c.get(a.id);if(null===b)return Infinity;if(void 0!==
b)return b;c.set(a.id,null);if(0===a.prevSegments.length)b=1;else{b=Infinity;var d=z(a.prevSegments),e;try{for(d.s();!(e=d.n()).done;){var m=w(e.value);m<b&&(b=m)}}catch(y){d.e(y)}finally{d.f()}b+=1}c.set(a.id,b);return b}var l=c.pop();if(0!==l.size){var A=new Set;d.cache=new Map;f.cache=new Map;w.cache=new Map;var n=f(b.initialSegment),D=na(e),g=ja(e),m=D?ea(D)||E(D):ha(e)||ia(e),u=Infinity,k=z(b.finalSegments),F;try{for(k.s();!(F=k.n()).done;){var ka=F.value;if(ka.reachable){var la=w(ka);la<u&&
(u=la)}}}catch(h){k.e(h)}finally{k.f()}l=z(l);var ma;try{for(l.s();!(ma=l.n()).done;){var r=ma.value,B=r[0],C=r[1];if(B.reachable){var v=0===B.nextSegments.length?u<=w(B):u<w(B),O=d(B)*f(B),P=A.has(B.id),L=z(C),Q;try{for(L.s();!(Q=L.n()).done;){var q=Q.value;P&&a.report({node:q,message:'React Hook "'+a.getSource(q)+'" may be executed more than once. Possibly because it is called in a loop. React Hooks must be called in the exact same order in every component render.'});if(m){if(!P&&O!==n){var W='React Hook "'+
a.getSource(q)+'" is called conditionally. React Hooks must be called in the exact same order in every component render.'+(v?" Did you accidentally call a React Hook after an early return?":"");a.report({node:q,message:W})}}else if(e.parent&&("MethodDefinition"===e.parent.type||"ClassProperty"===e.parent.type)&&e.parent.value===e){var R='React Hook "'+a.getSource(q)+'" cannot be called in a class component. React Hooks must be called in a React function component or a custom React Hook function.';
a.report({node:q,message:R})}else if(D){var M='React Hook "'+a.getSource(q)+'" is called in function "'+(a.getSource(D)+'" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word "use".');a.report({node:q,message:M})}else if("Program"===e.type){var J='React Hook "'+a.getSource(q)+'" cannot be called at the top level. React Hooks must be called in a React function component or a custom React Hook function.';
a.report({node:q,message:J})}else if(g){var K='React Hook "'+a.getSource(q)+'" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:q,message:K})}}}catch(h){L.e(h)}finally{L.f()}}}}catch(h){l.e(h)}finally{l.f()}}},CallExpression:function(a){if(E(a.callee)){var d=c[c.length-1],x=b[b.length-1],f=d.get(x);f||(f=[],d.set(x,f));f.push(a.callee)}}}}},"exhaustive-deps":{meta:{type:"suggestion",docs:{description:"verifies the list of dependencies for Hooks like useEffect and similar",
recommended:!0,url:"https://github.com/facebook/react/issues/14920"},fixable:"code",hasSuggestions:!0,schema:[{type:"object",additionalProperties:!1,enableDangerousAutofixThisMayCauseInfiniteLoops:!1,properties:{additionalHooks:{type:"string"},enableDangerousAutofixThisMayCauseInfiniteLoops:{type:"boolean"},ignoreThisDependency:{type:"string",enum:["never","props","always"]}}}]},create:function(a){function c(c){e&&Array.isArray(c.suggest)&&0<c.suggest.length&&(c.fix=c.suggest[0].fix);a.report(c)}
function b(a,c){return function(b){if(c.has(b))return c.get(b);var d=a(b);c.set(b,d);return d}}function d(d,e,f,k,F){function m(a){var c=z(a.references),b;try{for(c.s();!(b=c.n()).done;){var p=b.value;if(p.resolved&&B.has(p.resolved.scope)){var e=va(d,p.identifier),f=qa(e,x),h=Z(f,W),k;if(k=F&&"Identifier"===f.type&&("MemberExpression"===f.parent.type||"OptionalMemberExpression"===f.parent.type)&&!f.parent.computed&&"Identifier"===f.parent.property.type&&"current"===f.parent.property.name){for(var g=
p.from,u=!1;g.block!==d;)"function"===g.type&&(u=null!=g.block.parent&&"ReturnStatement"===g.block.parent.type),g=g.upper;k=u}k&&Q.set(h,{reference:p,dependencyNode:f});if("TSTypeQuery"!==f.parent.type&&"TSTypeReference"!==f.parent.type){var r=p.resolved.defs[0];if(null!=r&&(null==r.node||r.node.init!==d.parent)&&"TypeParameter"!==r.type)if(q.has(h))q.get(h).references.push(p);else{var l=p.resolved,t=P(l)||L(l);q.set(h,{isStable:t,references:[p]})}}}}}catch(ba){c.e(ba)}finally{c.f()}a=z(a.childScopes);
var n;try{for(a.s();!(n=a.n()).done;)m(n.value)}catch(ba){a.e(ba)}finally{a.f()}}function g(a){a=a.split(".");for(var c="",b=0;b<a.length;b++){if(0!==b){var p=a.slice(0,b+1).join(".");p=!0===W.get(p);c+=p?"?.":"."}c+=a[b]}return c}function u(a,c,b,d){return 0===a.size?null:(1<a.size?"":c+" ")+b+" "+(1<a.size?"dependencies":"dependency")+": "+xa(Array.from(a).sort().map(function(a){return"'"+g(a)+"'"}))+(". Either "+d+" "+(1<a.size?"them":"it")+" or remove the dependency array.")}F&&d.async&&c({node:d,
message:"Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching"});for(var r=w.acquire(d),B=new Set,C=null,v=r.upper;v;){B.add(v);if("function"===v.type)break;
v=v.upper}if(v){C=v;var O=Array.isArray,P=b(function(a){if(!O(a.defs))return!1;var c=a.defs[0];if(null==c||"VariableDeclarator"!==c.node.type)return!1;var b=c.node.init;if(null==b)return!1;for(;"TSAsExpression"===b.type;)b=b.expression;var d=c.node.parent;if(null==d&&(va(C.block,c.node.id),d=c.node.parent,null==d))return!1;if("const"===d.kind&&"Literal"===b.type&&("string"===typeof b.value||"number"===typeof b.value||null===b.value))return!0;if("CallExpression"!==b.type)return!1;b=b.callee;"MemberExpression"!==
b.type||"React"!==b.object.name||null==b.property||b.computed||(b=b.property);if("Identifier"!==b.type)return!1;c=c.node.id;b=b.name;if("useRef"===b&&"Identifier"===c.type)return!0;if("useState"===b||"useReducer"===b){if("ArrayPattern"===c.type&&2===c.elements.length&&O(a.identifiers)){if(c.elements[1]===a.identifiers[0]){if("useState"===b)for(a=a.references,b=0;b<a.length;b++)l.set(a[b].identifier,c.elements[0]);return!0}if(c.elements[0]===a.identifiers[0]&&"useState"===b)for(a=a.references,c=0;c<
a.length;c++)A.add(a[c].identifier)}}else if("useTransition"===b&&"ArrayPattern"===c.type&&2===c.elements.length&&Array.isArray(a.identifiers)&&c.elements[1]===a.identifiers[0])return!0;return!1},n),L=b(function(a){if(!O(a.defs))return!1;a=a.defs[0];if(null==a||null==a.node||null==a.node.id)return!1;var c=a.node,b=C.childScopes;a=null;var d;for(d=0;d<b.length;d++){var p=b[d],e=p.block;if("FunctionDeclaration"===c.type&&e===c||"VariableDeclarator"===c.type&&e.parent===c){a=p;break}}if(null==a)return!1;
for(d=0;d<a.through.length;d++)if(c=a.through[d],null!=c.resolved&&B.has(c.resolved.scope)&&!P(c.resolved))return!1;return!0},D),Q=new Map,q=new Map,W=new Map;m(r);Q.forEach(function(a,b){var d=a.dependencyNode;a=a.reference.resolved.references;for(var e=!1,p=0;p<a.length;p++){var f=a[p].identifier.parent;if(null!=f&&"MemberExpression"===f.type&&!f.computed&&"Identifier"===f.property.type&&"current"===f.property.name&&"AssignmentExpression"===f.parent.type&&f.parent.left===f){e=!0;break}}e||c({node:d.parent.property,
message:"The ref value '"+b+".current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy '"+(b+".current' to a variable inside the effect, and use that variable in the cleanup function.")})});var R=new Set,M=new Set;q.forEach(function(b,d){var e=b.references;b.isStable&&M.add(d);e.forEach(function(b){b.writeExpr&&(b=b.writeExpr,R.has(d)||(R.add(d),c({node:b,message:"Assignments to the '"+d+"' variable from inside React Hook "+
(a.getSource(f)+" will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside ")+(a.getSource(f)+".")})))})});if(!(0<R.size))if(e){var J=[],K=new Set;"ArrayExpression"!==e.type?c({node:e,message:"React Hook "+a.getSource(f)+" was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies."}):
e.elements.forEach(function(b){if(null!==b)if("SpreadElement"===b.type)c({node:b,message:"React Hook "+a.getSource(f)+" has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies."});else{try{var d=Z(b,null)}catch(sa){if(/Unsupported node type/.test(sa.message)){"Literal"===b.type?q.has(b.value)?c({node:b,message:"The "+b.raw+" literal is not a valid dependency because it never changes. Did you mean to include "+(b.value+" in the array instead?")}):
c({node:b,message:"The "+b.raw+" literal is not a valid dependency because it never changes. You can safely remove it."}):c({node:b,message:"React Hook "+a.getSource(f)+" has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked."});return}throw sa;}for(var e=b;"MemberExpression"===e.type||"OptionalMemberExpression"===e.type||"ChainExpression"===e.type;)e=e.object||e.expression.object;var p=!C.through.some(function(a){return a.identifier===
e});J.push({key:d,node:b});p||K.add(d)}});var h=G({dependencies:q,declaredDependencies:J,stableDependencies:M,externalDependencies:K,isEffect:F});v=h.unnecessaryDependencies;var H=h.missingDependencies,ra=h.duplicateDependencies,U=h.suggestedDependencies;if(0===ra.size+H.size+v.size)oa({declaredDependencies:J,declaredDependenciesNode:e,componentScope:C,scope:r}).forEach(function(a){var b=a.construction,d=a.isUsedOutsideOfHook;a=a.depType;var f="function"===a?"useCallback":"useMemo",m="function"===
a?"definition":"initialization",p="wrap the "+m+" of '"+b.name.name+"' in its own "+f+"() Hook.";p="The '"+b.name.name+"' "+a+" "+("conditional"===a||"logical expression"===a?"could make":"makes")+" the dependencies of "+(k+" Hook (at line "+e.loc.start.line+") change on every render. ")+(d?"To fix this, "+p:"Move it inside the "+k+" callback. Alternatively, "+p);var g;d&&"Variable"===b.type&&"function"===a&&(g=[{desc:"Wrap the "+m+" of '"+b.name.name+"' in its own "+f+"() Hook.",fix:function(a){var c=
"useMemo"===f?["useMemo(() => { return ","; })"]:["useCallback(",")"],d=c[1];return[a.insertTextBefore(b.node.init,c[0]),a.insertTextAfter(b.node.init,d)]}}]);c({node:b.node,message:p,suggest:g})});else{!F&&0<H.size&&(U=G({dependencies:q,declaredDependencies:[],stableDependencies:M,externalDependencies:K,isEffect:F}).suggestedDependencies);(function(){if(0===J.length)return!0;var a=J.map(function(a){return a.key}),b=a.slice().sort();return a.join(",")===b.join(",")})()&&U.sort();h="";if(0<v.size){var V=
null;Array.from(v.keys()).forEach(function(a){null===V&&a.endsWith(".current")&&(V=a)});if(null!==V)h=" Mutable values like '"+V+"' aren't valid dependencies because mutating them doesn't re-render the component.";else if(0<K.size){var I=Array.from(K)[0];r.set.has(I)||(h=" Outer scope values like '"+I+"' aren't valid dependencies because mutating them doesn't re-render the component.")}}if(!h&&H.has("props")){r=q.get("props");if(null==r)return;r=r.references;if(!Array.isArray(r))return;I=!0;for(var y=
0;y<r.length;y++){var N=va(C.block,r[y].identifier);if(!N){I=!1;break}N=N.parent;if(null==N){I=!1;break}if("MemberExpression"!==N.type&&"OptionalMemberExpression"!==N.type){I=!1;break}}I&&(h=" However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the "+(k+" call and refer to those specific props inside ")+(a.getSource(f)+"."))}if(!h&&0<H.size){var X=null;H.forEach(function(a){if(!X){var b=C.set.get(a),c=q.get(a);if(c.references[0].resolved===
b&&(b=b.defs[0],null!=b&&null!=b.name&&"Parameter"===b.type)){b=!1;for(var d,e=0;e<c.references.length;e++)if(d=c.references[e].identifier,null!=d&&null!=d.parent&&("CallExpression"===d.parent.type||"OptionalCallExpression"===d.parent.type)&&d.parent.callee===d){b=!0;break}b&&(X=a)}}});null!==X&&(h=" If '"+X+"' changes too often, find the parent component that defines it and wrap that definition in useCallback.")}if(!h&&0<H.size){var t=null;H.forEach(function(a){if(null===t)for(var b=q.get(a).references,
c,d,e=0;e<b.length;e++){c=b[e].identifier;for(d=c.parent;null!=d&&d!==C.block;){if("CallExpression"===d.type){var f=l.get(d.callee);if(null!=f){f.name===a?t={missingDep:a,setter:d.callee.name,form:"updater"}:A.has(c)?t={missingDep:a,setter:d.callee.name,form:"reducer"}:(c=b[e].resolved,null!=c&&(c=c.defs[0],null!=c&&"Parameter"===c.type&&(t={missingDep:a,setter:d.callee.name,form:"inlineReducer"})));break}}d=d.parent}if(null!==t)break}});if(null!==t)switch(t.form){case "reducer":h=" You can also replace multiple useState variables with useReducer if '"+
(t.setter+"' needs the current value of '")+(t.missingDep+"'.");break;case "inlineReducer":h=" If '"+t.setter+"' needs the current value of '"+(t.missingDep+"', you can also switch to useReducer instead of useState and read '")+(t.missingDep+"' in the reducer.");break;case "updater":h=" You can also do a functional update '"+t.setter+"("+t.missingDep.substring(0,1)+" => ...)' if you only need '"+t.missingDep+"' in the '"+(t.setter+"' call.");break;default:throw Error("Unknown case.");}}c({node:e,
message:"React Hook "+a.getSource(f)+" has "+(u(H,"a","missing","include")||u(v,"an","unnecessary","exclude")||u(ra,"a","duplicate","omit"))+h,suggest:[{desc:"Update the dependencies array to be: ["+U.map(g).join(", ")+"]",fix:function(a){return a.replaceText(e,"["+U.map(g).join(", ")+"]")}}]})}}else{var S=null;q.forEach(function(a,b){S||a.references.forEach(function(a){if(!S&&l.has(a.identifier)){for(a=a.from;"function"!==a.type;)a=a.upper;a.block===d&&(S=b)}})});if(S){var ca=G({dependencies:q,declaredDependencies:[],
stableDependencies:M,externalDependencies:new Set,isEffect:!0}).suggestedDependencies;c({node:f,message:"React Hook "+k+" contains a call to '"+S+"'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass ["+ca.join(", ")+("] as a second argument to the "+k+" Hook."),suggest:[{desc:"Add dependencies array: ["+ca.join(", ")+"]",fix:function(a){return a.insertTextAfter(d,", ["+ca.join(", ")+"]")}}]})}}}}var e=a.options&&a.options[0]&&a.options[0].enableDangerousAutofixThisMayCauseInfiniteLoops||
!1,x=a.options&&a.options[0]&&a.options[0].ignoreThisDependency||"never",f={additionalHooks:a.options&&a.options[0]&&a.options[0].additionalHooks?new RegExp(a.options[0].additionalHooks):void 0,enableDangerousAutofixThisMayCauseInfiniteLoops:e,ignoreThisDependency:x},w=a.getSourceCode().scopeManager,l=new WeakMap,A=new WeakSet,n=new WeakMap,D=new WeakMap;return{CallExpression:function(b){var e=ua(b.callee,f);if(-1!==e){var g=b.arguments[e],k=b.callee,l=ta(k).name,n=b.arguments[e+1];b=/Effect($|[^a-z])/g.test(l);
if(g)if(n||b){switch(g.type){case "FunctionExpression":case "ArrowFunctionExpression":d(g,n,k,l,b);return;case "Identifier":if(!n||n.elements&&n.elements.some(function(a){return a&&"Identifier"===a.type&&a.name===g.name}))return;e=a.getScope().set.get(g.name);if(null==e||null==e.defs)return;e=e.defs[0];if(!e||!e.node)break;if("Variable"!==e.type&&"FunctionName"!==e.type)break;switch(e.node.type){case "FunctionDeclaration":d(e.node,n,k,l,b);return;case "VariableDeclarator":if(e=e.node.init)switch(e.type){case "ArrowFunctionExpression":case "FunctionExpression":d(e,
n,k,l,b);return}}break;default:c({node:k,message:"React Hook "+l+" received a function whose dependencies are unknown. Pass an inline function instead."});return}c({node:k,message:"React Hook "+l+" has a missing dependency: '"+g.name+"'. Either include it or remove the dependency array.",suggest:[{desc:"Update the dependencies array to be: ["+g.name+"]",fix:function(a){return a.replaceText(n,"["+g.name+"]")}}]})}else"useMemo"!==l&&"useCallback"!==l||c({node:k,message:"React Hook "+l+" does nothing when called with only one argument. Did you forget to pass an array of dependencies?"});
else c({node:k,message:"React Hook "+l+" requires an effect callback. Did you forget to pass a callback to the hook?"})}}}}}};
